
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>ElasticPyProxy : A controller for dynamic scaling of Haproxy backend servers &#8212; ElasticPyProxy 1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="elasticpyproxy-a-controller-for-dynamic-scaling-of-haproxy-backend-servers">
<h1>ElasticPyProxy : A controller for dynamic scaling of Haproxy backend servers<a class="headerlink" href="#elasticpyproxy-a-controller-for-dynamic-scaling-of-haproxy-backend-servers" title="Permalink to this headline">¶</a></h1>
<p>ElasticPyProxy (EP2) is a controller written completely in python for dynamically scaling HAProxy backend servers. Using this
controller, it is possible to integrate HAProxy with a server orchestrator which spwans servers dynamically and scales
out and in very frequently. As of now it provides support for the following:</p>
<ul class="simple">
<li><p>AWS Autoscaling groups</p></li>
<li><p>Consul</p></li>
</ul>
<p>however handler for any orchestrator which exposes an API for getting live backends can be added easily.</p>
<p>It is to be noted that <strong>consul is not a orchestrator</strong> but a service discovery tool. It can be used to discovery
A given service can be discovered with consul and later the hosts/nodes which are the provider of that service
can be discovered by either consul DNS or consul catalog API. If a node providing the given services goes down,
the api will remove those nodes from the catalogue and show only the live ones.</p>
<p>In the rest of the documentation we will continue refering to AWS ASG while explaining the differemt features
of EP2 but evrything will be applicable to Consul as well.</p>
<p>So, going ahead with aws, it is possible, using EP2 to integrate HAProxy with a AWS Autoscaling Group. Once integrated, the
HAProxy backend servers will scale out and in with the ASG of interest. Thus, whenever the ASG spawns a new instance, that
instance will get added to haproxy’s concerned backend/listener and when the ASG removes a backend, that particular server
will also be removed from HAProxy’s concerned backend/listener.</p>
<p>Know more about Hashicorp Consul <a class="reference external" href="https://www.consul.io/">here</a></p>
<p>In the rest of the documentation, for simplicity the term <strong>orchestrator</strong> will be used to refer to AWS ASG
and consul (although consul is not an orchestrator as already mentioned above but a service discovery mechanism,
any orchestrator can be exposed via consul, even AWS ASG) and the backend servers will be refered to as
just <strong>backends</strong></p>
<p>View EP2 on <a class="reference external" href="https://www.github.com/djmgit/ElasticPyProxy">Github</a></p>
<div class="section" id="how-ep2-works">
<h2>How EP2 works<a class="headerlink" href="#how-ep2-works" title="Permalink to this headline">¶</a></h2>
<p>Simple put EP2, continuously polls the orchestrator and checks what are the available backends and updates haproxy accordingly.
However it can be made to do this simple job in more than one way as needed by the user or the host system. Following are the
main tasks done by the components present in EP2</p>
<div class="section" id="ep2-working">
<h3>EP2 working<a class="headerlink" href="#ep2-working" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>The system where EP2 runs should have the HAProxy (v1.8 or above) binary, HAproxy UNIX socket exposed and
accessible, optionally systemd service file properly configured.</p></li>
<li><p>When EP2 starts, the first thing it does is bootstrap the controller. The bootstrapping includes creating clients
for accessing the orchestrator, making the first call to orchestrator API for getting current live backends, updating
the haproxy config file using the provided template.</p></li>
<li><p>Once the config file has been updated, the bootstrapper checks if HAProxy is already running. If it is already running,
the bootstrapper simply reloads HAProxy so that the new configuration takes affect. If Haproxy is stopped the it starts
it.</p></li>
<li><p>Once bootstrap is done, we now have a running haproxy with the current live backends added to it. Post this, EP2 enters
its poll-update-repeat loop.</p></li>
<li><p>Once EP2 enters the loop, it primarily does two things. Firstly it polls the orchestrator for the current backend nodes. On
getting the list of current live backends it compares it against a locally saved in memory list of live backends.
If there is a difference, it updates the local in-memory list and goes on to update HAProxy otherwise it does nothing</p></li>
<li><p>EP2 can update haproxy in two ways. First way is, it simply formats the configured haproxy template file with the live
backend servers, updates the HAProxy config file with the contents of the formatted template file and reloads HAProxy.</p></li>
<li><p>Since HAProxy reload (post v1.8) is hitless, reload wont cause any downtime.</p></li>
<li><p>EP2 allows two ways to reload HAProxy, one via systemd service and the other via the HAProxy binary. The respective params
must be provided in EP2 config accordingly. More on this below.</p></li>
<li><p>The issue with the above method of updating is, HAProxy has to be reloaded. When the number of reloads is less, it is not
a big issue. However if the number of reload is too high, it can cause overhead since reload essentially involves  transfer
of connections/sockets from old process to the new process.</p></li>
<li><p>The second method of updation is the one in which reload is not required at all. It updates HAProxy in runtime using the
UNIX socket file it exposes. This is to some extent complicated than the previous method. Once the new backends are added
the config file is also updated so that the runtime configuration and the config file on disk remains consistent, but there
is no need to reload HAProxy.</p></li>
<li><p>Once updation is done, it waits for a configured amount of time before polling for backends again and repeating the same
processes.</p></li>
</ul>
</div>
<div class="section" id="major-components-of-ep2">
<h3>Major components of EP2<a class="headerlink" href="#major-components-of-ep2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p>Backend fetcher : The backend fetcher fetches the live backends from the configured orchestrator. As mentioned earlier
for now this is AWS ASG and Consul.</p></li>
<li><p>HaproxyUpdater : This updates the HAProxy, either by updating config or via socket at runtime.</p></li>
<li><p>ConfigHandler : This is used by HaproxyUpdater to handle the HAProxy config updation</p></li>
<li><p>RuntimeUpdater : This is used by HaproxyUpdater to update HAProxy at runtime via socket.</p></li>
<li><p>HaproxyReloader : This is used to reload HAProxy wither via systemd or via binary.</p></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="backend-fetcher">
<h2>Backend fetcher<a class="headerlink" href="#backend-fetcher" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The awsfetcher and the consulfetcher, fetches the available servers in the concerned asg or service respectively.
For AWS ASG, boto3 library is used and for Consul, the Consul catalog API is used.</p>
</div></blockquote>
</div>
<div class="section" id="updating-haproxy-via-config">
<h2>Updating HAProxy via config<a class="headerlink" href="#updating-haproxy-via-config" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>As mentioned above, one of the ways HAProxy can be updated using EP2 is via updating its config direcly. In both the
updation methods, EP2 is preconfigured with a template HAProxy config (mentioned below).</p>
<p>Once the current live backend servers are available, EP2 formats the template and populates it with the current live backends.
Then it replaces the contents of the actually HAProxy config file with the contents of this formatted template file.
After this is done it reloads HAProxy either via <strong>systemd</strong> or via <strong>binary</strong>.</p>
<p>Both the path to Haproxy config file and path to the HAProxy template file should be provided in EP2 config.</p>
</div></blockquote>
</div>
<div class="section" id="updating-haproxy-at-runtime">
<h2>Updating HAProxy at Runtime<a class="headerlink" href="#updating-haproxy-at-runtime" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In this method, HAProxy has to be preconfigured with a number of inactive or disabled backend servers. This is taken care of
by the <strong>bootstrapper</strong>. When bootstrap runs, apart from creating the live backend servers it also creates a number of
inactive dummy backend servers with dummy address.</p>
<p>The number of dummy backend servers to be created is decided by the config param <strong>node_slots</strong>. If the number of live backend
servers fetched from the orchestrator is <strong>x</strong>, then the number of dummy inactive servers created is <strong>node_slots - x</strong>.</p>
<p>Now whenever a scale in activity happens, that is the orchestrator removes some of the live servers, EP2 finds out which
servers are out of service. It marks them as inactive and adds them to the inactive pool.</p>
<p>Whenever a new server is spawned up, EP2 picks an inactive server from the pool, changes its address to the address of the
newly spawned backend server and marks it as ready. Thus the inactive server now becomes active and it represents the
newly spawned backend server.</p>
<p>Once the runtime config of HAProxy has been updated, same configuration is replicated in the config file so that it stays at
par with the running config of HAProxy.</p>
<p>It is worth noting that in this procedure, the value of the <strong>node_slots</strong> param should always be greater than the
total amount of live servers the orchestrator can contain/spawn at any given time. This should be easily
figured out from the <strong>min/max</strong> criteria of the orchestrator in use.</p>
</div></blockquote>
</div>
<div class="section" id="reloading-haproxy-via-systemd">
<h2>Reloading HAProxy via systemd<a class="headerlink" href="#reloading-haproxy-via-systemd" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>When updating HAProxy via config, HAProxy has to be reloaded and one such way to reload HAProxy is via <strong>systemd</strong>. For this
there should be a properly configured systemd service file such that systemd reload works properly.</p>
<p>The command used is the usual systemd command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">systemctl</span> <span class="n">reoad</span> <span class="p">[</span><span class="n">haproxy_servicefile_name</span><span class="p">]</span>
</pre></div>
</div>
<p>The HAProxy systemd service file name should be provided as a EP2 config param.</p>
</div></blockquote>
</div>
<div class="section" id="reloading-haproxy-via-binary">
<h2>Reloading HAProxy via binary<a class="headerlink" href="#reloading-haproxy-via-binary" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The other way to reload haproxy is by executing the binary. For this is to work the following things must be provided in EP2
config :</p>
<ul class="simple">
<li><p>haproxy_config_file : The haproxy config file</p></li>
<li><p>haproxy_binary : The location of the HAProxy binary which is usually <code class="docutils literal notranslate"><span class="pre">/usr/sbin/haproxy</span></code></p></li>
<li><p>haproxy_socket_file : The location of the HAProxy unix socket file.</p></li>
<li><p>pid_file : The location of the HAProxy PID file which is usually <code class="docutils literal notranslate"><span class="pre">/run/haproxy.pid</span></code></p></li>
</ul>
<p>The command fired is the usual one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[haproxy_binary] -W -q -D -f [haproxy_config_file] -p [pid_file] -x [socket_file] -sf $(cat [pid_file])
</pre></div>
</div>
<p>The above causes hitless reload of HAProxy.</p>
</div></blockquote>
</div>
<div class="section" id="bootstrapping-ep2">
<h2>Bootstrapping EP2<a class="headerlink" href="#bootstrapping-ep2" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>At the very beginning when EP2 is started, bootstrapping takes place. The following essentially happens in the bootstrap
process :</p>
<ul class="simple">
<li><p>The desired nodefetcher is initialised. As of now it is the <strong>awsfetcher</strong>. As a part of the initialisation of the
awsfetcher, the asg and ec2 boto3 clients are created using the provided aws credentials.</p></li>
<li><p>The the very first call to get the live backend servers is made.</p></li>
<li><p>Once EP2 has the live backend server addresses, irrespective of whether EP2 is configured to use update via config or
update at runtime, EP2 updates the haproxy config with the formatted template file contents. It is during this time
EP2 creates the inactive pool if it is configured to use updae by runtime on later runs.</p></li>
<li><p>Once the updation is done, it checks whether HAProxy is running or not. If its not running, the it starts HAProxy.
If it was running then it simply reloads it using the configured method.</p></li>
<li><p>Once bootstrap is done, EP2 enters its loop.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="installing-ep2">
<h2>Installing EP2<a class="headerlink" href="#installing-ep2" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>EP2 can be installed either using pip or can be built from source.</p>
<p><strong>Installing via pip</strong></p>
<p>Inorder to install via pip, execute the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">pip3</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">djmgit</span><span class="o">/</span><span class="n">ElasticPyProxy</span>
</pre></div>
</div>
<p><strong>Installing from source</strong></p>
<p>Inorder to install from source perform the following actions:</p>
<ul class="simple">
<li><p>Clone this repo and enter into it using <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">https://github.com/djmgit/ElasticPyProxy.git</span></code></p></li>
<li><p>Run the following command <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">python3</span> <span class="pre">setup.py</span> <span class="pre">install</span></code></p></li>
</ul>
<p>Once installation is done, ep2 will be installed at <strong>/usr/bin/ep2</strong></p>
<p>Also the following files and directories will be created:</p>
<ul class="simple">
<li><p>/var/log/ep2</p></li>
<li><p>/etc/ep2</p></li>
<li><p>/etc/ep2/ep2.conf</p></li>
<li><p>/etc/ep2/haproxy.cfg.template</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="configuring-ep2">
<h2>Configuring EP2<a class="headerlink" href="#configuring-ep2" title="Permalink to this headline">¶</a></h2>
<p>A sample EP2 config file is given below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">haproxy</span><span class="p">]</span>
<span class="n">haproxy_config_file</span> <span class="o">=</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">haproxy</span><span class="o">/</span><span class="n">haproxy</span><span class="o">.</span><span class="n">cfg</span>
<span class="n">template_file</span> <span class="o">=</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">deep</span><span class="o">/</span><span class="n">elasticpyproxy</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">haproxy</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">template</span>
<span class="n">backend_port</span> <span class="o">=</span> <span class="mi">6003</span>
<span class="n">haproxy_binary</span> <span class="o">=</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">haproxy</span>
<span class="n">start_by</span> <span class="o">=</span> <span class="n">systemd</span>
<span class="n">haproxy_socket_file</span> <span class="o">=</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">haproxy</span><span class="o">/</span><span class="n">haproxy</span><span class="o">.</span><span class="n">sock</span>
<span class="n">pid_file</span> <span class="o">=</span> <span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">haproxy</span><span class="o">.</span><span class="n">pid</span>
<span class="n">backend_name</span> <span class="o">=</span> <span class="n">haproxynode</span>
<span class="n">update_type</span> <span class="o">=</span> <span class="n">update_by_runtime</span>
<span class="n">node_slots</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">service_name</span> <span class="o">=</span> <span class="n">haproxy</span>
<span class="n">lock_dir</span> <span class="o">=</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">deep</span><span class="o">/</span><span class="n">elasticpyproxy</span><span class="o">/</span><span class="n">etc</span>
<span class="n">orchestrator</span> <span class="o">=</span> <span class="n">aws</span>
<span class="n">sleep_before_next_run</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">log_file</span> <span class="o">=</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">log</span><span class="o">/</span><span class="n">ep2</span><span class="o">/</span><span class="n">ep2</span><span class="o">.</span><span class="n">log</span>

<span class="p">[</span><span class="n">AWS</span><span class="p">]</span>
<span class="n">aws_access_key_id</span> <span class="o">=</span>
<span class="n">aws_secret_access_key</span> <span class="o">=</span>
<span class="n">asg_name</span> <span class="o">=</span>
<span class="n">region_name</span> <span class="o">=</span>
</pre></div>
</div>
<p>For Consul, the following block can be used instead of [AWS]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">CONSUL</span><span class="p">]</span>
<span class="n">service_name</span> <span class="o">=</span>
<span class="n">consul_ip</span> <span class="o">=</span>
<span class="n">consul_port</span> <span class="o">=</span>
<span class="n">only_passing</span> <span class="o">=</span>
<span class="n">tags</span> <span class="o">=</span>
</pre></div>
</div>
<p>Params involved:</p>
<ul class="simple">
<li><p>haproxy_config_file : This is the path to the actual haproxy config file. Usually it is /etc/haproxy/haproxy.cfg</p></li>
<li><p>template_file : Path to the template file. This is the file that will be populated and used to update the actual haproxy config file.</p></li>
<li><p>backend_port : The port used by backend servers.</p></li>
<li><p>haproxy_binary : The HAProxy binary file location.</p></li>
<li><p>start_by : How to start/reload HAProxy. Can be <strong>systemd</strong> or <strong>binary</strong></p></li>
<li><p>haproxy_socket_file : Path to HAProxy socket file</p></li>
<li><p>pid_file : Path to HAProxy pid file</p></li>
<li><p>backend_name : The name of the HAProxy backend/listener name under which the live backend servers fetched from orchestrator will be added.</p></li>
<li><p>backend_maxconn : Max connections for individual backends</p></li>
<li><p>check_interval : Interval for performing health checks for individual backends</p></li>
<li><p>update_type : How to update HAProxy. Either <strong>update_by_config</strong> or <strong>udpate_by_runtime</strong></p></li>
<li><p>node_slots : Total number of slots for backend servers. As mentioned above, this will be used to calculate inactive servers.</p></li>
<li><p>service_name : Service name for HAProxy systemd service. Required only when using reload by systemd</p></li>
<li><p>lock_dir : Path to directory for storing EP2 lock file.</p></li>
<li><p>orchestrator : The backend orchestrator. As of now it can only be <strong>aws</strong></p></li>
<li><p>sleep_before_next_run : Amount of time to wait before next poll-update run</p></li>
<li><p>log_file : The file to output logs</p></li>
</ul>
<p>[AWS]</p>
<ul class="simple">
<li><p>aws_access_key_id : aws creds</p></li>
<li><p>aws_secret_access_key : aws creds</p></li>
<li><p>asg_name : Name of the autoscaling group</p></li>
<li><p>region_name : aws region name where the asg exists</p></li>
</ul>
<p>[CONSUL]</p>
<ul class="simple">
<li><p>service_name : Name of the service which has already been registered with consul and whose providers we want to discover</p></li>
<li><p>consul_ip : IP adress where consul catalog API is running. Default is 127.0.0.1. If the node where EP2 is running has been added the the consul cluster, then consul api should be accessed via 127.0.0.1 if not changed otherwise.</p></li>
<li><p>consul_port : Port for the Consul catalog API. Default is 8500</p></li>
<li><p>only_passing : can be <strong>True</strong> or <strong>False</strong>. If True, then only those backends will be discovered and added for which the service checks are passing. Please refer Consul doc to learn more about service checks. Default value is True.</p></li>
<li><p>tags : Comma separated values of tags to filter services.</p></li>
</ul>
<p>A sample haproxy template file is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>global
        log /dev/log  local0
        log /dev/log  local1 notice
        chroot /var/lib/haproxy
        stats socket /var/run/haproxy/haproxy.sock mode 660 level admin expose-fd listeners
        stats timeout 30s
        user haproxy
        group haproxy
        daemon

        # Default SSL material locations
        ca-base /etc/ssl/certs
        crt-base /etc/ssl/private

        # Default ciphers to use on SSL-enabled listening sockets.
        # For more information, see ciphers(1SSL). This list is from:
        #  https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
        # An alternative list with additional directives can be obtained from
        #  https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=haproxy
        ssl-default-bind-ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!MD5:!DSS
        ssl-default-bind-options no-sslv3
        stats socket ipv4@127.0.0.1:9999 level admin
  stats timeout 2m

defaults
        log   global
        mode  http
        option        httplog
        option        dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
        errorfile 400 /etc/haproxy/errors/400.http
        errorfile 403 /etc/haproxy/errors/403.http
        errorfile 408 /etc/haproxy/errors/408.http
        errorfile 500 /etc/haproxy/errors/500.http
        errorfile 502 /etc/haproxy/errors/502.http
        errorfile 503 /etc/haproxy/errors/503.http
        errorfile 504 /etc/haproxy/errors/504.http

listen haproxynode
        bind *:7001
        balance roundrobin
        option forwardfor
        http-request set-header X-Forwarded-Port %[dst_port]
        http-request set-header X-CLIENT-IP %[src]
        http-request add-header X-Forwarded-Proto https if {{ ssl_fc }}
        option httpchk HEAD / HTTP/1.1\r\nHost:localhost
        {{nodes}}

listen stats
    bind :32700
    stats enable
    stats uri /stat
    stats hide-version
</pre></div>
</div>
<p>The backend/listener used (<code class="docutils literal notranslate"><span class="pre">haproxynode</span></code>) in this case should be mentioned in <strong>EP2 config</strong>.
The backend/listener of interest should have the template varibale <code class="docutils literal notranslate"><span class="pre">nodes</span></code> in jinja templating format.
This template varibale will be replaced with the live backend servers in each run.</p>
<p>Once this template is formatted, the actual HAProxy config will be updated with the formatted contents of this
template file.</p>
<p>So, whatever changes one usually has to make to HAProxy config, they have to be made here.</p>
</div>
<div class="section" id="starting-ep2">
<h2>Starting EP2<a class="headerlink" href="#starting-ep2" title="Permalink to this headline">¶</a></h2>
<p>Execute the following for starting EP2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">ep2</span> <span class="o">-</span><span class="n">f</span> <span class="p">[</span><span class="n">Path</span> <span class="n">to</span> <span class="n">ep2</span><span class="o">.</span><span class="n">conf</span><span class="p">]</span>
</pre></div>
</div>
<p>Stop EP2 by CTRL+C.</p>
<p>The ideal way to run EP2 would be to use a process manager like <strong>systemd</strong> or <strong>supervisord</strong>.</p>
</div>
<div class="section" id="elasticpyproxy-code-documentation">
<h2>ElasticPyProxy Code Documentation<a class="headerlink" href="#elasticpyproxy-code-documentation" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="module-src.driver.driver">
<span id="driver-main-entry-point-for-elasticpyproxy"></span><h3>driver (Main entry point for ElasticPyProxy)<a class="headerlink" href="#module-src.driver.driver" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-driver"></span><dl class="function">
<dt id="src.driver.driver.drive">
<code class="sig-prename descclassname">src.driver.driver.</code><code class="sig-name descname">drive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/driver/driver.html#drive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.driver.driver.drive" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Method for starting ep2</strong></p>
<p>This is the entry method which starts ep2 controller. It calls bootstrap module
for bootstrapping ep2, reads ep2 config, initialises haproxy and starts the
<strong>poll-update-repeat loop</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns nothing</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-src.driver.drivercache">
<span id="drivercache-cache-layer-for-ep2"></span><h3>drivercache : Cache layer for EP2<a class="headerlink" href="#module-src.driver.drivercache" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-drivercache"></span><dl class="class">
<dt id="src.driver.drivercache.DriverCache">
<em class="property">class </em><code class="sig-prename descclassname">src.driver.drivercache.</code><code class="sig-name descname">DriverCache</code><span class="sig-paren">(</span><em class="sig-param">node_ips</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/driver/drivercache.html#DriverCache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.driver.drivercache.DriverCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to provide caching for ep2</p>
<p>The backends fetched in a given run is stored in memory.
The backends fetched in next run witll be compared to the ones already
held by this class (node_ips). If there is a mismatch, only then update
will be done</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_ips</strong> (<em>list</em>) – list of backend IPs</p>
</dd>
</dl>
<dl class="method">
<dt id="src.driver.drivercache.DriverCache.need_to_update">
<code class="sig-name descname">need_to_update</code><span class="sig-paren">(</span><em class="sig-param">node_ips</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/driver/drivercache.html#DriverCache.need_to_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.driver.drivercache.DriverCache.need_to_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to check if haproxy needs to be updated</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_ips</strong> (<em>list</em>) – list of backend IPs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether to update haproxy or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.driver.bootstrap">
<span id="bootstrap-bootstrapper-for-ep2"></span><h3>bootstrap : Bootstrapper for ep2<a class="headerlink" href="#module-src.driver.bootstrap" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-bootstrap"></span><dl class="function">
<dt id="src.driver.bootstrap.bootstrap">
<code class="sig-prename descclassname">src.driver.bootstrap.</code><code class="sig-name descname">bootstrap</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/driver/bootstrap.html#bootstrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.driver.bootstrap.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to bootstrap EP2 controller</p>
<p>This method bootstraps EP2 to creates the neccessary objects and returns it
to the driver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>object</em>) – kwargs must contains config dictionary, logger object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether bootstrap updater was successfull or not
src.core.haproxyupdater.haproxyupdate.HaproxyUPdate: Object for updating haproxy config
src.core.nodefetchers.basefetcher: Object for fetching backends</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-src.core.haproxyupdater.haproxyupdate">
<span id="haproxyupdate-module-for-updating-haproxy"></span><h3>haproxyupdate : Module for updating haproxy<a class="headerlink" href="#module-src.core.haproxyupdater.haproxyupdate" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-haproxyupdate"></span><dl class="class">
<dt id="src.core.haproxyupdater.haproxyupdate.HaproxyUpdate">
<em class="property">class </em><code class="sig-prename descclassname">src.core.haproxyupdater.haproxyupdate.</code><code class="sig-name descname">HaproxyUpdate</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/haproxyupdate.html#HaproxyUpdate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.haproxyupdate.HaproxyUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for handling haproxy update and reload</p>
<p>This class contains handlers which controls haproxy uptation and reload.
Haproxy can be updated wither by updating its config file followed by
a reload via systemd or via binary. The other way to reload haproxy is
via the exposed socket. This type of update does not require any reload</p>
<p>For updating via runtime haproxy needs to maintain a pool if inactive
backends. When a new live backend comes, we can pull an inactive live backend
and make it live changing its ip to that of the live backend</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – params in key/value dict format</p>
</dd>
</dl>
<dl class="attribute">
<dt id="src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.logger">
<code class="sig-name descname">logger</code><em class="property"> = None</em><a class="headerlink" href="#src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Valid methods to start haproxy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>init methods is not supported yet.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.update_haproxy">
<code class="sig-name descname">update_haproxy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/haproxyupdate.html#HaproxyUpdate.update_haproxy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.update_haproxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates haproxy config</p>
<p>This method updates haproxy config with the help of the util methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Wether haproxy was updated successfully or not.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.update_haproxy_by_config_reload">
<code class="sig-name descname">update_haproxy_by_config_reload</code><span class="sig-paren">(</span><em class="sig-param">update_only=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/haproxyupdate.html#HaproxyUpdate.update_haproxy_by_config_reload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.update_haproxy_by_config_reload" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to update haproxy via config reload</p>
<p>This method will update haproxy via updating its config and subsequently reloading it.
The actual update will be done by the confighandler module and reload will be
done by haproxyreloader. Optinaly is <strong>upate_only</strong> is set to True then only config
will be updated and reload will not be done.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>update_only</strong> (<em>bool</em>) – Whether only update is required or both update and reload is required.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether successfully updated/reloaded as the case may be</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.update_node_list">
<code class="sig-name descname">update_node_list</code><span class="sig-paren">(</span><em class="sig-param">node_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/haproxyupdate.html#HaproxyUpdate.update_node_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.update_node_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to update active node list</p>
<p>This method will e called to update the list of active backends.
Haproxy needs to be updated and optionally reloaded if this list changes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_list</strong> (<em>list</em>) – List containing IPs/Hostnames of active backends</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.valid_start_by">
<code class="sig-name descname">valid_start_by</code><em class="property"> = None</em><a class="headerlink" href="#src.core.haproxyupdater.haproxyupdate.HaproxyUpdate.valid_start_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Valid methods to update haproxy</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.core.haproxyupdater.confighandler">
<span id="confighandler-module-for-updating-haproxy"></span><h3>confighandler : Module for updating haproxy<a class="headerlink" href="#module-src.core.haproxyupdater.confighandler" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-confighandler"></span><dl class="class">
<dt id="src.core.haproxyupdater.confighandler.ConfigHandler">
<em class="property">class </em><code class="sig-prename descclassname">src.core.haproxyupdater.confighandler.</code><code class="sig-name descname">ConfigHandler</code><a class="reference internal" href="_modules/src/core/haproxyupdater/confighandler.html#ConfigHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.confighandler.ConfigHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to handler haproxy config file updation</p>
<p>This class contains method for updating the haproxy config file
with the provided formatted haproxy config template.</p>
<p>The template is first populated with the fetched backends using jinja templating
engine and then the haproxy config file is updated with this formatted template.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
</dl>
<dl class="method">
<dt id="src.core.haproxyupdater.confighandler.ConfigHandler.read_write_file">
<em class="property">static </em><code class="sig-name descname">read_write_file</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/confighandler.html#ConfigHandler.read_write_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.confighandler.ConfigHandler.read_write_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to read and write haproxy config file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>successfully updated or not
str : error string if any</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.haproxyupdater.confighandler.ConfigHandler.update_config">
<em class="property">static </em><code class="sig-name descname">update_config</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/confighandler.html#ConfigHandler.update_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.confighandler.ConfigHandler.update_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for updating haproxy config</p>
<p>This is the method which actually updates the haproxy config file
using the provided template file after properly formatting it</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Successfully updated or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.core.haproxyupdater.haproxyreloader">
<span id="haproxyreloader-module-for-reloading-haproxy"></span><h3>haproxyreloader : Module for reloading haproxy<a class="headerlink" href="#module-src.core.haproxyupdater.haproxyreloader" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-haproxyreloader"></span><dl class="class">
<dt id="src.core.haproxyupdater.haproxyreloader.HaproxyReloader">
<em class="property">class </em><code class="sig-prename descclassname">src.core.haproxyupdater.haproxyreloader.</code><code class="sig-name descname">HaproxyReloader</code><a class="reference internal" href="_modules/src/core/haproxyupdater/haproxyreloader.html#HaproxyReloader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.haproxyreloader.HaproxyReloader" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for handling haproxy reload</p>
<p>This class provides methods to reload haproxy, either
via systemd or via the binary.</p>
<p>In order to reload via bianry, the socket file and the PID file
should be present as params along with the binary location.</p>
<p>For systemd, the systemd service name should be provided
as param.</p>
<p>Both reload via systemd and reload via binary are done by execting shell
commands via subprocess library</p>
<dl class="method">
<dt id="src.core.haproxyupdater.haproxyreloader.HaproxyReloader.reload_haproxy">
<em class="property">static </em><code class="sig-name descname">reload_haproxy</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/haproxyreloader.html#HaproxyReloader.reload_haproxy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.haproxyreloader.HaproxyReloader.reload_haproxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for reloading haproxy</p>
<p>Method for reloading haproxy. This takes the help of util method to reload
haproxy either via systemd or binary.</p>
<p>Other classes and methods will call this method for updating haporoxy
with the required param.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary conatining params</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Successfully reloaded or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.haproxyupdater.haproxyreloader.HaproxyReloader.start_by_systemd">
<em class="property">static </em><code class="sig-name descname">start_by_systemd</code><span class="sig-paren">(</span><em class="sig-param">service_name</em>, <em class="sig-param">logger=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/haproxyreloader.html#HaproxyReloader.start_by_systemd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.haproxyreloader.HaproxyReloader.start_by_systemd" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for starting haproxy via systemd</p>
<p>Starts haproxy via systemd. Executes systemd start as a shell command.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logger</strong> (<em>object</em>) – logger object for logging</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Successfully started or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.core.haproxyupdater.runtimeupdater">
<span id="runtimeupdater-module-for-updating-haproxy-at-runtime"></span><h3>runtimeupdater : Module for updating haproxy at runtime<a class="headerlink" href="#module-src.core.haproxyupdater.runtimeupdater" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-runtimeupdater"></span><dl class="class">
<dt id="src.core.haproxyupdater.runtimeupdater.RuntimeUpdater">
<em class="property">class </em><code class="sig-prename descclassname">src.core.haproxyupdater.runtimeupdater.</code><code class="sig-name descname">RuntimeUpdater</code><a class="reference internal" href="_modules/src/core/haproxyupdater/runtimeupdater.html#RuntimeUpdater"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.runtimeupdater.RuntimeUpdater" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for updating haproxy at runtime</p>
<p>This class conatins methods for updating haproxy backends at
runtime without reloading it.</p>
<p>This is done by communicating with haproxy over the unix
socket file expsed by it.</p>
<p>Once ep2 gets the ips/hostnames of the live backends, it
communicates with haproxy over socket, extracts servers
from inactive pool and updating their address with that of
the live ones.</p>
<dl class="method">
<dt id="src.core.haproxyupdater.runtimeupdater.RuntimeUpdater.update_haproxy_runtime">
<em class="property">static </em><code class="sig-name descname">update_haproxy_runtime</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/runtimeupdater.html#RuntimeUpdater.update_haproxy_runtime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.runtimeupdater.RuntimeUpdater.update_haproxy_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to update haproxy at runtime using the util method present above</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Successfully updated haproxy or not
stats : dictionary containing active nodes and inactive node count</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.haproxyupdater.runtimeupdater.RuntimeUpdater.update_runtime_util">
<em class="property">static </em><code class="sig-name descname">update_runtime_util</code><span class="sig-paren">(</span><em class="sig-param">haproxy_sock</em>, <em class="sig-param">node_ips</em>, <em class="sig-param">nodes</em>, <em class="sig-param">backend_name</em>, <em class="sig-param">port</em>, <em class="sig-param">logger=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/runtimeupdater.html#RuntimeUpdater.update_runtime_util"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.runtimeupdater.RuntimeUpdater.update_runtime_util" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for updating haproxy backends using unix socket</p>
<p>This method updates the haproxy backends by sending commands over the
exposed unix socket.</p>
<p><strong>Working</strong></p>
<ul class="simple">
<li><p>First it iterates over the active backends currently present in haproxy.</p></li>
<li><p>If they are not present in the current fetched list of backends, then we
disable those backends and add them to the inactive pool.</p></li>
<li><p>Next we iterate over the list of current live nodes fetched from orchestrator</p></li>
<li><p>if they are already present as live backends in haproxy <strong>even after the above
elimination</strong> then we skip.</p></li>
<li><p>If they are not present then we fetch a inactive node from the inactive pool,
change its address to that of the live node and enable back that node.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>haproxy_sock</strong> (<em>str</em>) – Location of the haproxy unix socket file</p></li>
<li><p><strong>node_ips</strong> (<em>list</em>) – List of current live nodes fetched from orchestrator. (IP or hostname)</p></li>
<li><p><strong>nodes</strong> (<em>dictionary</em>) – Dictionary conatining haproxy active and inactive backends</p></li>
<li><p><strong>backend_name</strong> (<em>str</em>) – Name of the haproxy backend that needs to be updated.</p></li>
<li><p><strong>port</strong> (<em>int</em>) – port for the backend nodes</p></li>
<li><p><strong>logger</strong> (<em>object</em>) – Logger object</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Retuns:</dt><dd><p>dict : Dictionary conatining active node_ips and inactive nodes count</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.core.haproxyupdater.sockethandler">
<span id="sockethandler-module-for-handling-socket-operations"></span><h3>sockethandler : Module for handling socket operations<a class="headerlink" href="#module-src.core.haproxyupdater.sockethandler" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-sockethandler"></span><dl class="class">
<dt id="src.core.haproxyupdater.sockethandler.SocketHandler">
<em class="property">class </em><code class="sig-prename descclassname">src.core.haproxyupdater.sockethandler.</code><code class="sig-name descname">SocketHandler</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/sockethandler.html#SocketHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.sockethandler.SocketHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Class containing methods for handling socket operation</p>
<p>This is a generic class for handling all socket operation.
All the commands which are to be sent to haproxy and done via methods in
this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
</dl>
<dl class="method">
<dt id="src.core.haproxyupdater.sockethandler.SocketHandler.connect_socket">
<code class="sig-name descname">connect_socket</code><span class="sig-paren">(</span><em class="sig-param">sock_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/sockethandler.html#SocketHandler.connect_socket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.sockethandler.SocketHandler.connect_socket" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to connect to haproxy unix socket</p>
<p>This method creates a socket connection to the given haproxy unix socket</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Successfully created socket connection or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.haproxyupdater.sockethandler.SocketHandler.send_command">
<code class="sig-name descname">send_command</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/haproxyupdater/sockethandler.html#SocketHandler.send_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.haproxyupdater.sockethandler.SocketHandler.send_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to send command to haproxy unix socket and get response</p>
<p>It will first create a socket connection to the haproxy socket
and then send the given command and get response.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Successfully sent command or not
str : response sent by the haproxy unix socket</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.core.nodefetchers.basefetcher">
<span id="basefetcher-provides-base-class-for-backend-fetchers"></span><h3>basefetcher : Provides base class for backend fetchers<a class="headerlink" href="#module-src.core.nodefetchers.basefetcher" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-basefectcher"></span><dl class="class">
<dt id="src.core.nodefetchers.basefetcher.BaseFetcher">
<em class="property">class </em><code class="sig-prename descclassname">src.core.nodefetchers.basefetcher.</code><code class="sig-name descname">BaseFetcher</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/basefetcher.html#BaseFetcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.basefetcher.BaseFetcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all kinds of backend fetchers</p>
<p>This class is the base/super class for all backend fetchers.
Individual backend fetchers have to inherit this class and
an optionally override the methods present in this class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
</dl>
<dl class="method">
<dt id="src.core.nodefetchers.basefetcher.BaseFetcher.fetch">
<code class="sig-name descname">fetch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/basefetcher.html#BaseFetcher.fetch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.basefetcher.BaseFetcher.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for fecthing backend nodes from orchestrator</p>
<p>Make request for nodes. Should be overridden by individual fetchers</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.core.nodefetchers.orchestrator">
<span id="orchestrator-module-for-providing-appropriate-backend-fetcher"></span><h3>orchestrator : Module for providing appropriate backend fetcher<a class="headerlink" href="#module-src.core.nodefetchers.orchestrator" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-orchestrator"></span><dl class="function">
<dt id="src.core.nodefetchers.orchestrator.get_orchestrator_handler">
<code class="sig-prename descclassname">src.core.nodefetchers.orchestrator.</code><code class="sig-name descname">get_orchestrator_handler</code><span class="sig-paren">(</span><em class="sig-param">config</em>, <em class="sig-param">logger=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/orchestrator.html#get_orchestrator_handler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.orchestrator.get_orchestrator_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for deciding which fetcher to use</p>
<p>Decide which fetcher to use depending on the orchestrator mentioned
in the config.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> (<em>dictionary</em>) – dictionary holding ep2 config</p></li>
<li><p><strong>logger</strong> (<em>object</em>) – logger object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Backend fetcher</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.core.nodefetchers.orchestrator.prepare_aws_handler">
<code class="sig-prename descclassname">src.core.nodefetchers.orchestrator.</code><code class="sig-name descname">prepare_aws_handler</code><span class="sig-paren">(</span><em class="sig-param">config</em>, <em class="sig-param">logger</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/orchestrator.html#prepare_aws_handler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.orchestrator.prepare_aws_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the AWS fetcher</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>config</strong> (<em>dictionary</em>) – dictionary containing ep2 config</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Aws backend fetecher</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>srv.nodefetchers.awsfetcher.awsfetcher</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.core.nodefetchers.orchestrator.prepare_consul_handler">
<code class="sig-prename descclassname">src.core.nodefetchers.orchestrator.</code><code class="sig-name descname">prepare_consul_handler</code><span class="sig-paren">(</span><em class="sig-param">config</em>, <em class="sig-param">logger</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/orchestrator.html#prepare_consul_handler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.orchestrator.prepare_consul_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the Consul fetcher</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>config</strong> (<em>dictionary</em>) – dictionary containing ep2 config</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Consul backend fetcher</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>srv.nodefetchers.consulfetcher.cosulfetcher</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-src.core.nodefetchers.awsfetcher.awsfetcher">
<span id="awsfetcher-module-for-fecthing-live-backends-from-aws"></span><h3>awsfetcher : Module for fecthing live backends from AWS<a class="headerlink" href="#module-src.core.nodefetchers.awsfetcher.awsfetcher" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-awsfetcher"></span><dl class="class">
<dt id="src.core.nodefetchers.awsfetcher.awsfetcher.AwsFetcher">
<em class="property">class </em><code class="sig-prename descclassname">src.core.nodefetchers.awsfetcher.awsfetcher.</code><code class="sig-name descname">AwsFetcher</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/awsfetcher/awsfetcher.html#AwsFetcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.awsfetcher.awsfetcher.AwsFetcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for fetching libe backends from AWS</p>
<p>Contains methods to fetch live backends from AWS using the boto3 library
To make this class work properly, ep2 config must have aws section with
access_key_id and secret_access_token specified along with aws region
and ip_type which is required (public or private)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>dictionary</em>) – Dictionary containing params</p>
</dd>
</dl>
<dl class="method">
<dt id="src.core.nodefetchers.awsfetcher.awsfetcher.AwsFetcher.fetch">
<code class="sig-name descname">fetch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/awsfetcher/awsfetcher.html#AwsFetcher.fetch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.awsfetcher.awsfetcher.AwsFetcher.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for fetching backends</p>
<p>This method takes help of BotoHandler for fetching backends from AWS
and return them to the caller</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List of backends</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.core.nodefetchers.awsfetcher.botohandler">
<span id="botohandler-module-for-handling-aws-operations"></span><h3>botohandler : Module for handling AWS operations<a class="headerlink" href="#module-src.core.nodefetchers.awsfetcher.botohandler" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-botohandler"></span><dl class="class">
<dt id="src.core.nodefetchers.awsfetcher.botohandler.BotoHandler">
<em class="property">class </em><code class="sig-prename descclassname">src.core.nodefetchers.awsfetcher.botohandler.</code><code class="sig-name descname">BotoHandler</code><a class="reference internal" href="_modules/src/core/nodefetchers/awsfetcher/botohandler.html#BotoHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.awsfetcher.botohandler.BotoHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for handling aws node fetching operations</p>
<p>Methods in this class handle aws operations for retreiving the
list of active backends. It first uses boto3 asg client for
describing the asg of interest. Once we have the instance ids
in that asg, we use ec2 client for describing those instances
for getting their public/private ips</p>
<dl class="method">
<dt id="src.core.nodefetchers.awsfetcher.botohandler.BotoHandler.get_auto_scaling_client">
<em class="property">static </em><code class="sig-name descname">get_auto_scaling_client</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/awsfetcher/botohandler.html#BotoHandler.get_auto_scaling_client"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.awsfetcher.botohandler.BotoHandler.get_auto_scaling_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for initialising asg boto client</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>object</em>) – kwargs must contains config dictionary, logger object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>boto3 asg client</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boto3.client</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.nodefetchers.awsfetcher.botohandler.BotoHandler.get_ec2_client">
<em class="property">static </em><code class="sig-name descname">get_ec2_client</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/awsfetcher/botohandler.html#BotoHandler.get_ec2_client"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.awsfetcher.botohandler.BotoHandler.get_ec2_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for initialising ec2 boto client</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>object</em>) – kwargs must contains config dictionary, logger object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>boto3 ec2 client</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boto3.client</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src.core.nodefetchers.awsfetcher.botohandler.BotoHandler.get_instance_ips_for_asg">
<em class="property">static </em><code class="sig-name descname">get_instance_ips_for_asg</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/src/core/nodefetchers/awsfetcher/botohandler.html#BotoHandler.get_instance_ips_for_asg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#src.core.nodefetchers.awsfetcher.botohandler.BotoHandler.get_instance_ips_for_asg" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for getting aws live instance IPs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<em>object</em>) – kwargs must contains config dictionary, logger object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of live backend IPs</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h3>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">ElasticPyProxy</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Deepjyoti Mondal.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>